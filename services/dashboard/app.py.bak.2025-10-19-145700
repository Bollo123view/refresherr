from __future__ import annotations
import os, sqlite3, math, time
from flask import Flask, render_template, request, redirect, url_for, flash, jsonify
import requests

# --- Config ---
DATA_DIR = os.environ.get("DATA_DIR", "/data")
DB_PATH = os.path.join(DATA_DIR, "symlinks.db")

# Relay for searches
RELAY_BASE = os.environ.get("RELAY_BASE", "")
RELAY_TOKEN = os.environ.get("RELAY_TOKEN", "")

# Symlink root on host (mounted into container)
SYMLINK_ROOT = os.environ.get("SYMLINK_ROOT", "/opt/media/jelly")

# Optional simple routing by path prefix â†’ instance
INSTANCE_BY_PREFIX = [
    ("/opt/media/jelly/4k",   "radarr_movie"),
    ("/opt/media/jelly/movies","radarr_movie"),
    ("/opt/media/jelly/tv",   "sonarr_tv"),
    ("/opt/media/jelly/hayu", "sonarr_hayu"),
]

app = Flask(__name__)
app.secret_key = os.environ.get("FLASK_SECRET", "refresherr-demo-secret")

# --- DB ---
def db():
    p = DB_PATH
    if not os.path.exists(p):
        raise RuntimeError(f"DB missing at {p}")
    conn = sqlite3.connect(p, timeout=5, check_same_thread=False)
    conn.row_factory = sqlite3.Row
    conn.execute("PRAGMA foreign_keys=ON;")
    conn.execute("PRAGMA busy_timeout=5000;")
    return conn

def sizeof_fmt(num: int) -> str:
    for unit in ["B","KB","MB","GB","TB"]:
        if num < 1024.0:
            return f"{num:.1f} {unit}"
        num /= 1024.0
    return f"{num:.1f} PB"

@app.context_processor
def inject_helpers():
    return dict(sizeof_fmt=sizeof_fmt)

@app.route("/health")
def health():
    try:
        c = db().cursor()
        c.execute("SELECT 1")
        return jsonify(ok=True)
    except Exception as e:
        return jsonify(ok=False, error=str(e)), 500

@app.route("/dbcheck")
def dbcheck():
    try:
        conn = db(); c = conn.cursor()
        out = {}
        for name in ("movies","movie_files","series","episode_files","symlinks"):
            try:
                c.execute(f"SELECT COUNT(*) FROM {name}")
                out[name] = c.fetchone()[0]
            except Exception as ex:
                out[name] = f"err: {ex}"
        try:
            cols = conn.execute("PRAGMA table_info(symlinks)").fetchall()
            names = {r["name"] for r in cols}
            out["symlinks_has_last_status"] = "last_status" in names
            out["symlinks_has_status"] = "status" in names
            out["symlinks_has_last_seen_ts"] = "last_seen_ts" in names
        except Exception as ex:
            out["pragma_err"] = str(ex)
        return out
    except Exception as e:
        return {"error": str(e)}, 500

@app.route("/")
def index():
    try:
        conn = db(); cur = conn.cursor()
        cur.execute("SELECT COUNT(*) FROM movie_files WHERE symlink_path IS NOT NULL"); movies_linked = cur.fetchone()[0]
        cur.execute("SELECT COUNT(*) FROM movie_files"); movies_total = cur.fetchone()[0]
        cur.execute("SELECT COUNT(*) FROM episode_files WHERE symlink_path IS NOT NULL"); eps_linked = cur.fetchone()[0]
        cur.execute("SELECT COUNT(*) FROM episode_files"); eps_total = cur.fetchone()[0]

        broken = 0
        try:
            cur.execute("SELECT COUNT(*) FROM symlinks WHERE COALESCE(last_status, status)='broken'")
            broken = cur.fetchone()[0]
        except Exception:
            broken = 0

        mov_pct = (movies_linked / movies_total * 100.0) if movies_total else 0.0
        eps_pct = (eps_linked / eps_total * 100.0) if eps_total else 0.0
        return render_template("index.html",
            movies_linked=movies_linked, movies_total=movies_total, mov_pct=mov_pct,
            eps_linked=eps_linked, eps_total=eps_total, eps_pct=eps_pct,
            broken=broken, relay_ok=bool(RELAY_BASE and RELAY_TOKEN))
    except Exception as e:
        return (f"<pre>Index error: {e}</pre>", 500)

def paginate(q, page, per_page=50):
    total = len(q)
    start = (page-1)*per_page
    end = start + per_page
    items = q[start:end]
    pages = math.ceil(total/per_page) if per_page else 1
    return items, total, pages

@app.route("/movies")
def movies():
    conn = db()
    q = request.args.get("q","").strip().lower()
    rows = conn.execute("""
        SELECT mf.id, mf.instance, mf.quality, mf.resolution, mf.size_bytes, mf.symlink_path
        FROM movie_files mf
        WHERE mf.symlink_path IS NOT NULL
        ORDER BY mf.id DESC
    """).fetchall()
    items = []
    for r in rows:
        sp = r["symlink_path"] or ""
        title = os.path.basename(os.path.dirname(sp)) if sp else ""
        if q and q not in title.lower():
            continue
        items.append({
            "id": r["id"],
            "instance": r["instance"],
            "title": title,
            "quality": r["quality"],
            "resolution": r["resolution"],
            "size": r["size_bytes"],
            "symlink_path": sp
        })
    page = int(request.args.get("page", "1") or "1")
    page_items, total, pages = paginate(items, page, per_page=50)
    return render_template("movies.html", items=page_items, total=total, page=page, pages=pages, q=q)

@app.route("/episodes")
def episodes():
    conn = db()
    q = request.args.get("q","").strip().lower()
    rows = conn.execute("""
        SELECT ef.id, ef.instance, ef.season_number, ef.quality, ef.resolution, ef.size_bytes, ef.symlink_path,
               ef.sonarr_series_id, s.title as series_title
        FROM episode_files ef
        LEFT JOIN series s ON s.sonarr_id = ef.sonarr_series_id AND s.instance = ef.instance
        WHERE ef.symlink_path IS NOT NULL
        ORDER BY ef.id DESC
    """).fetchall()
    items = []
    for r in rows:
        sp = r["symlink_path"] or ""
        epname = os.path.basename(sp) if sp else ""
        title = (r["series_title"] or "")
        if q and (q not in title.lower() and q not in epname.lower()):
            continue
        items.append({
            "id": r["id"],
            "instance": r["instance"],
            "series_title": title,
            "episode_name": epname,
            "season": r["season_number"],
            "quality": r["quality"],
            "resolution": r["resolution"],
            "size": r["size_bytes"],
            "symlink_path": sp
        })
    page = int(request.args.get("page", "1") or "1")
    page_items, total, pages = paginate(items, page, per_page=50)
    return render_template("episodes.html", items=page_items, total=total, page=page, pages=pages, q=q)

@app.route("/broken")
def broken():
    conn = db()
    rows = conn.execute("""
        SELECT path, last_target, COALESCE(last_status, status) AS status, last_seen_ts
        FROM symlinks
        WHERE COALESCE(last_status, status)='broken'
        ORDER BY last_seen_ts DESC
        LIMIT 200
    """).fetchall()
    items = []
    for r in rows:
        sp = r["path"]
        term = os.path.basename(os.path.dirname(sp))
        items.append({
            "path": sp,
            "target": r["last_target"],
            "term": term,
            "status": r["status"]
        })
    return render_template("broken.html", items=items, relay_ok=bool(RELAY_BASE and RELAY_TOKEN))

def pick_instance_from_path(p: str) -> str | None:
    for prefix, instance in INSTANCE_BY_PREFIX:
        if p.startswith(prefix):
            return instance
    return None

@app.post("/action/auto")
def action_auto():
    if not (RELAY_BASE and RELAY_TOKEN):
        flash("Relay not configured", "danger")
        return redirect(request.referrer or url_for("index"))

    term = (request.form.get("term") or "").strip()
    typ  = (request.form.get("type") or "").strip()
    path = (request.form.get("path") or "").strip()

    if not term and path:
        try:
            term = os.path.basename(os.path.dirname(path)) or ""
        except Exception:
            term = ""

    if not (term and path):
        flash("Missing term or path", "danger")
        return redirect(request.referrer or url_for("index"))

    if not path.startswith(SYMLINK_ROOT.rstrip("/") + "/"):
        flash("Refusing to modify a path outside the symlink root.", "danger")
        return redirect(request.referrer or url_for("index"))

    if not typ:
        inst = pick_instance_from_path(path)
        if inst is None:
            inst = "sonarr_tv" if "/tv/" in path or "/hayu/" in path else "radarr_movie"
    else:
        inst = typ

    conn = db()
    cur  = conn.cursor()
    now  = int(time.time())

    # Safe unlink
    try:
        if os.path.islink(path):
            os.unlink(path)
        else:
            flash("Not a symlink; leaving file untouched.", "warning")
    except Exception as e:
        flash(f"Unlink failed: {e}", "warning")

    # Mark repairing & clear target
    try:
        cur.execute("""
            UPDATE symlinks
               SET last_status='repairing',
                   last_target=NULL,
                   last_seen_ts=?
             WHERE path=?
        """, (now, path))
        conn.commit()
    except Exception as e:
        flash(f"DB update failed: {e}", "danger")

    # Ensure actions exists and insert
    try:
        cur.execute("""
        CREATE TABLE IF NOT EXISTS actions (
          id            INTEGER PRIMARY KEY AUTOINCREMENT,
          created_ts    INTEGER  DEFAULT (strftime('%s','now')),
          source        TEXT,
          instance      TEXT,
          subject_type  TEXT,
          subject_id    INTEGER,
          subject_title TEXT,
          scope         TEXT,
          status        TEXT  DEFAULT 'enqueued',
          last_error    TEXT
        )
        """)
        subject_type = "series" if inst.startswith("sonarr") else "movie"
        cur.execute("""
            INSERT INTO actions(source, instance, subject_type, subject_id, subject_title, scope, status)
            VALUES(?,?,?,?,?,?,?)
        """, ("dashboard", inst, subject_type, None, term, "auto", "enqueued"))
        conn.commit()
    except Exception as e:
        flash(f"Action log insert failed: {e}", "warning")

    # Relay call
    try:
        resp = requests.get(RELAY_BASE, params={
            "token": RELAY_TOKEN,
            "type": inst,
            "scope": "auto",
            "term": term
        }, timeout=20)
        ok = 200 <= resp.status_code < 300
        msg = f"AUTO {inst} '{term}': {resp.status_code} {resp.text[:160]}"
        flash(msg, "success" if ok else "warning")
        try:
            cur.execute("UPDATE actions SET status=? WHERE id=(SELECT MAX(id) FROM actions)", ("ok" if ok else "failed",))
            if not ok:
                cur.execute("UPDATE actions SET last_error=? WHERE id=(SELECT MAX(id) FROM actions)", (resp.text[:300],))
            conn.commit()
        except Exception:
            pass
    except Exception as e:
        flash(f"AUTO failed: {e}", "danger")
        try:
            cur.execute("UPDATE actions SET status=?, last_error=? WHERE id=(SELECT MAX(id) FROM actions)", ("failed", str(e)[:300]))
            conn.commit()
        except Exception:
            pass

    return redirect(request.referrer or url_for("index"))

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=int(os.environ.get("PORT","8088")), debug=False)
