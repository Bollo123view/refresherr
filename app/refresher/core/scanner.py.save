import os, time, csv, io, yaml, re, urllib.parse, requests
from dataclasses import dataclass
from typing import List, Tuple
from .mounts import is_mount_present
from .notifier import post_discord_simple, post_discord_file, discord_webhook_url_from_env
from .relay_client import relay_from_env
from .history import add_events

@dataclass
class Config:
    roots: List[str]
    rewrites: List[Tuple[str,str]]
    mount_checks: List[str]
    discord_env: str
    relay_base_env: str
    relay_token_env: str

def load_config() -> Config:
    cfg_path = os.environ.get("CONFIG_FILE", "/config/config.yaml")
    with open(cfg_path, "r", encoding="utf-8") as f:
        raw = yaml.safe_load(f) or {}
    roots = raw.get("scan", {}).get("roots", [])
    rewrites = [(x.get("from"), x.get("to")) for x in raw.get("scan", {}).get("rewrites", [])]
    mounts = raw.get("scan", {}).get("mount_checks", [])
    discord_env = raw.get("notifications", {}).get("discord_webhook_env", "DISCORD_WEBHOOK")
    relay_base_env = raw.get("relay", {}).get("base_env", "RELAY_BASE")
    relay_token_env = raw.get("relay", {}).get("token_env", "RELAY_TOKEN")
    return Config(roots, rewrites, mounts, discord_env, relay_base_env, relay_token_env)

def rewrite_target(target: str, rewrites: List[Tuple[str,str]]) -> str:
    for src, dst in rewrites:
        if src and target.startswith(src):
            return target.replace(src, dst, 1)
    return target

def _extract_season_from_path(path: str):
    """
    Detect a season number from segments like:
      - 'Season 4', 'Season_4', 'Season-04'
      - 'S04', 's04'
    Returns int or None.
    """
    parts = re.split(r"[\\/]", path)
    for seg in parts:
        m = re.match(r"(?i)^season[ _-]?(\d{1,2})$", seg)
        if m:
            return int(m.group(1))
        m2 = re.match(r"(?i)^s(\d{2})$", seg)
        if m2:
            return int(m2.group(1))
    return None

def classify(path: str):
    """
    Return (kind, name, season_number|None)
    kind: tv | hayu | doc | 4k
    """
    season = _extract_season_from_path(path)

    if "/jelly/4k/" in path:
        name = os.path.basename(os.path.dirname(path))
        return ("4k", name, season)
    if "/jelly/doc/" in path:
        name = os.path.basename(os.path.dirname(path))
        return ("doc", name, season)
    if "/jelly/hayu/" in path:
        base = os.path.dirname(os.path.dirname(path))
        return ("hayu", os.path.basename(base), season)
    base = os.path.dirname(os.path.dirname(path))
    return ("tv", os.path.basename(base), season)

def scan_once(cfg: Config, dryrun: bool = True) -> dict:
    # Mount checks
    for m in cfg.mount_checks:
        if not is_mount_present(m):
            return {"ok": False, "error": f"mount not present: {m}"}

    broken = []
    for root in cfg.roots:
        if not os.path.isdir(root):
            continue
        for dirpath, _, filenames in os.walk(root):
            for name in filenames:
                full = os.path.join(dirpath, name)
                if not os.path.islink(full):
                    continue
                try:
                    target = os.readlink(full)
                except OSError:
                    target = ""
                resolved = rewrite_target(target, cfg.rewrites)
                if not os.path.exists(resolved):
                    kind, showname, season = classify(full)
                    broken.append((full, target, resolved, kind, showname, season))

    # Prepare CSV + unique actions (one per (kind,name,season) for TV/Hayu; one per movie for Radarr)
    buf = io.StringIO()
    w = csv.writer(buf)
    w.writerow(["Type","Name","Season","Path","Target","Resolved","Scope","FindLink"])
    now = int(time.time())
    evt_rows = []
    unique_actions = {}  # key -> (label, url)

    webhook = discord_webhook_url_from_env(cfg.discord_env)
    base_url, token = relay_from_env(cfg.relay_base_env, cfg.relay_token_env)

    def build_link(kind: str, name: str, season: int|None) -> tuple[str,str]:
        link_type = {"tv":"sonarr_tv","hayu":"sonarr_hayu","doc":"radarr_doc","4k":"radarr_4k"}.get(kind,"sonarr_tv")
        if not (base_url and token):
            return ("series" if kind in ("tv","hayu") else "movie", "")
        qname = urllib.parse.quote(name)
        if kind in ("tv","hayu") and season:
            return ("season", f"{base_url}?type={link_type}&term={qname}&scope=season&season={season}&token={token}")
        scope = "series" if kind in ("tv","hayu") else "movie"
        return (scope, f"{base_url}?type={link_type}&term={qname}&scope={scope}&token={token}")

    for (p, t, r, kind, name, season) in broken:
        scope, url = build_link(kind, name, season)
        w.writerow([kind, name, season or "", p, t, r, scope, url])
        evt_rows.append((now, p, t, kind, name, "detected", "dryrun" if dryrun else "delete"))

        # group action key: TV/Hayu grouped by season if present; movies grouped by title
        key = (kind, name, season if kind in ("tv","hayu") else None)
        if key not in unique_actions:
            label = f"{name} â€“ Season {season}" if (kind in ("tv","hayu") and season) else name
            unique_actions[key] = (label, url)

    csv_bytes = buf.getvalue().encode("utf-8")

    summary = {"ok": True, "broken_count": len(broken), "dryrun": dryrun}

    # Post to Discord (summary + grouped quick actions + full CSV)
    if webhook:
        msg = f"ðŸ§ª refresher scan (dry-run={str(dryrun).lower()}): {len(broken)} broken symlinks"
        post_discord_simple(webhook, msg)
        if unique_actions:
            lines = ["ðŸ”Ž Quick actions (grouped):"]
            for (label, url) in list(unique_actions.values())[:25]:
                lines.append(f"â€¢ [{label}]({url})" if url else f"â€¢ {label}")
            post_discord_simple(webhook, "\n".join(lines))
        if broken:
            post_discord_file(webhook, "refresher_broken.csv", csv_bytes, "Full report")

    # History DB
    if evt_rows:
        add_events(evt_rows)

    # Delete pass (if enabled)
    if not dryrun:
        for (p, _, _, _, _, _) in broken:
            try:
                os.remove(p)
            except OSError:
                pass

    return summary

def one_scan():
    cfg = load_config()
    dry = os.environ.get("DRYRUN","true").lower() == "true"
    res = scan_once(cfg, dryrun=dry)
    print(res)

def run_loop():
    cfg = load_config()
    dry = os.environ.get("DRYRUN","true").lower() == "true"
    interval = int(os.environ.get("SCAN_INTERVAL","86400"))
    while True:
        scan_once(cfg, dryrun=dry)
        time.sleep(interval)
