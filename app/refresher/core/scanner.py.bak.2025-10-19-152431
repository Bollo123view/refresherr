import os, time, json, sqlite3, pathlib, requests

DB_PATH = "/data/symlinks.db"
SYMLINK_ROOT = os.environ.get("SYMLINK_ROOT", "/opt/media/jelly")
MOUNT_ROOT   = os.environ.get("MOUNT_ROOT", "/mnt/remote/realdebrid")
LOG_LEVEL    = os.environ.get("REFRESHER_LOG_LEVEL", "INFO").upper()

def log(level, msg):
    levels = ["DEBUG","INFO","WARNING","ERROR"]
    if levels.index(level) >= levels.index(LOG_LEVEL):
        print(f"{level} refresher.scanner: {msg}", flush=True)

def db():
    conn = sqlite3.connect(DB_PATH, timeout=10, isolation_level=None)
    conn.row_factory = sqlite3.Row
    return conn

def ensure_tables(conn):
    c = conn.cursor()
    c.execute("""CREATE TABLE IF NOT EXISTS symlinks(
        path TEXT PRIMARY KEY,
        ext TEXT,
        last_target TEXT,
        last_status TEXT,
        last_size_bytes INTEGER,
        last_mtime_ns   INTEGER,
        first_seen_ts   INTEGER,
        last_seen_ts    INTEGER,
        times_seen      INTEGER DEFAULT 0,
        is_current      INTEGER DEFAULT 1
    )""")
    c.execute("CREATE INDEX IF NOT EXISTS idx_symlinks_status  ON symlinks(last_status)")
    c.execute("CREATE INDEX IF NOT EXISTS idx_symlinks_ext     ON symlinks(ext)")
    c.execute("CREATE INDEX IF NOT EXISTS idx_symlinks_current ON symlinks(is_current)")
    c.execute("""CREATE TABLE IF NOT EXISTS actions(
      id             INTEGER PRIMARY KEY AUTOINCREMENT,
      created_utc    INTEGER  DEFAULT (strftime('%s','now')),
      url            TEXT,
      reason         TEXT,
      related_path   TEXT,
      source         TEXT,
      instance       TEXT,
      subject_type   TEXT,
      subject_id     INTEGER,
      subject_title  TEXT,
      scope          TEXT,
      status         TEXT DEFAULT 'pending',
      last_error     TEXT
    )""")
    c.execute("CREATE INDEX IF NOT EXISTS idx_actions_status  ON actions(status)")
    c.execute("CREATE INDEX IF NOT EXISTS idx_actions_created ON actions(created_utc)")
    conn.commit()

def is_broken_symlink(p: pathlib.Path):
    if not p.is_symlink():
        return (False, None)
    try:
        target = os.readlink(p)
        full = pathlib.Path(target)
        if not full.is_absolute():
            full = (p.parent / target).resolve()
        return (not full.exists(), target)
    except OSError:
        return (True, None)

def record_symlink(conn, path: str, target: str, status: str, st=None):
    c = conn.cursor()
    ext = pathlib.Path(path).suffix.lower()
    size = getattr(st, "st_size", None)
    mtime = getattr(st, "st_mtime_ns", None)
    now = int(time.time())
    c.execute("""
        INSERT INTO symlinks(path,ext,last_target,last_status,last_size_bytes,last_mtime_ns,first_seen_ts,last_seen_ts,times_seen,is_current)
        VALUES(?,?,?,?,?,?,?,?,?,1)
        ON CONFLICT(path) DO UPDATE SET
          ext=excluded.ext,
          last_target=excluded.last_target,
          last_status=excluded.last_status,
          last_size_bytes=excluded.last_size_bytes,
          last_mtime_ns=excluded.last_mtime_ns,
          last_seen_ts=?,
          times_seen=symlinks.times_seen+1,
          is_current=1
    """,(path,ext,target,status,size,mtime,now,now,1, now))
    conn.commit()

def scan_once():
    conn = db()
    ensure_tables(conn)
    root = pathlib.Path(SYMLINK_ROOT)
    if not root.exists():
        log("WARNING", f"SYMLINK_ROOT missing: {SYMLINK_ROOT}")
        return
    n_ok=n_broken=0
    for p in root.rglob("*"):
        if not p.is_symlink():
            continue
        try:
            broken, target = is_broken_symlink(p)
            st = p.lstat()
        except Exception:
            broken, target, st = True, None, None
        status = "broken" if broken else "ok"
        record_symlink(conn, str(p), target, status, st)
        if broken: n_broken += 1
        else: n_ok += 1
    log("INFO", f"Scan summary: {n_ok+n_broken} symlinks; {n_ok} ok; {n_broken} broken")

def unlink_if_symlink(path: str):
    try:
        if os.path.islink(path):
            os.unlink(path)
            return True
    except Exception as e:
        log("WARNING", f"unlink failed {path}: {e}")
    return False

def update_symlink_status(conn, path: str, status: str):
    c = conn.cursor()
    now = int(time.time())
    try:
        c.execute("UPDATE symlinks SET last_status=?, last_seen_ts=?, is_current=1 WHERE path=?",
                  (status, now, path))
    except sqlite3.OperationalError:
        c.execute("UPDATE symlinks SET status=?, last_seen_utc=datetime('now') WHERE path=?",
                  (status, path))
    conn.commit()

def get_pending(conn, limit=5):
    return conn.execute(
        "SELECT * FROM actions WHERE status='pending' ORDER BY created_utc LIMIT ?",
        (limit,)
    ).fetchall()

def mark_sent(conn, action_id: int, ok: bool, err: str=None):
    conn.execute("UPDATE actions SET status=?, last_error=? WHERE id=?",
                 ("sent" if ok else "failed", None if ok else (err or ""), action_id))
    conn.commit()

def process_actions():
    conn = db()
    ensure_tables(conn)
    rows = get_pending(conn, limit=5)
    if not rows:
        return
    log("INFO", f"processing {len(rows)} pending action(s)")
    for r in rows:
        aid = r["id"]
        url = r["url"]
        related = r["related_path"]
        try:
            if related:
                update_symlink_status(conn, related, "repairing")
                unlink_if_symlink(related)
            resp = requests.get(url, timeout=20)
            ok = 200 <= resp.status_code < 300
            if not ok:
                mark_sent(conn, aid, False, f"{resp.status_code} {resp.text}")
            else:
                mark_sent(conn, aid, True, None)
            log("INFO", f"ACTION {aid} -> {'OK' if ok else 'FAIL'}")
        except Exception as e:
            mark_sent(conn, aid, False, str(e))
            log("ERROR", f"ACTION {aid} exception: {e}")

def run_loop(interval_seconds: int = 300):
    log("INFO", f"loop every {interval_seconds}s")
    while True:
        try:
            scan_once()
        except Exception as e:
            log("ERROR", f"scan error: {e}")
        try:
            process_actions()
        except Exception as e:
            log("ERROR", f"actions error: {e}")
        time.sleep(interval_seconds)

if __name__ == "__main__":
    import argparse
    ap = argparse.ArgumentParser()
    ap.add_argument("--json", action="store_true")
    args = ap.parse_args()
    if args.json:
        try:
            scan_once()
            print(json.dumps({"ok": True}))
        except Exception as e:
            print(json.dumps({"ok": False, "error": str(e)}))
    else:
        run_loop(300)
