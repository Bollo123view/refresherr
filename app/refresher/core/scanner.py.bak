import os, time, json, sqlite3, pathlib, requests

DB_PATH = "/data/symlinks.db"
SYMLINK_ROOT = os.environ.get("SYMLINK_ROOT", "/opt/media/jelly")
LOG_LEVEL    = os.environ.get("REFRESHER_LOG_LEVEL", "INFO").upper() 
IGNORE_SUBSTR = os.environ.get("IGNORE_SUBSTR", "cinesync").split(",")

def is_ignored_path(p: pathlib.Path) -> bool:
    s = str(p).lower()
    for raw in IGNORE_SUBSTR:
        pat = raw.strip().lower()
        if not pat:
            continue
        # match either as substring in full path OR as an exact folder name
        if pat in s or any(part.lower() == pat for part in p.parts):
            return True
    return False
    
def log(level, msg):
    levels = ["DEBUG","INFO","WARNING","ERROR"]
    if levels.index(level) >= levels.index(LOG_LEVEL):
        print(f"{level} refresher.scanner: {msg}", flush=True)

def db():
    conn = sqlite3.connect(DB_PATH, timeout=10, isolation_level=None)
    conn.row_factory = sqlite3.Row
    return conn

def ensure_actions(conn):
    c = conn.cursor()
    c.execute("""CREATE TABLE IF NOT EXISTS actions(
      id             INTEGER PRIMARY KEY AUTOINCREMENT,
      created_utc    INTEGER  DEFAULT (strftime('%s','now')),
      url            TEXT,
      reason         TEXT,
      related_path   TEXT,
      source         TEXT,
      instance       TEXT,
      subject_type   TEXT,
      subject_id     INTEGER,
      subject_title  TEXT,
      scope          TEXT,
      status         TEXT DEFAULT 'pending',
      last_error     TEXT
    )""")
    c.execute("CREATE INDEX IF NOT EXISTS idx_actions_status  ON actions(status)")
    c.execute("CREATE INDEX IF NOT EXISTS idx_actions_created ON actions(created_utc)")
    conn.commit()

def table_cols(conn, name: str):
    rows = conn.execute(f"PRAGMA table_info('{name}')").fetchall()
    return {r["name"] for r in rows}

def is_broken_symlink(p: pathlib.Path):
    if not p.is_symlink():
        return (False, None)
    try:
        target = os.readlink(p)
        full = pathlib.Path(target)
        if not full.is_absolute():
            full = (p.parent / target).resolve()
        return (not full.exists(), target)
    except OSError:
        return (True, None)

def record_symlink(conn, path: str, target: str, status: str, st=None):
    cols = table_cols(conn, "symlinks")
    if not cols:
        # If the table doesn't exist at all, create a minimal one compatible with your current schema.
        conn.execute("""CREATE TABLE IF NOT EXISTS symlinks(
            path TEXT PRIMARY KEY,
            last_target TEXT,
            last_status TEXT
        )""")
        cols = table_cols(conn, "symlinks")

    # Build insert/update payload based on available columns
    data = {"path": path}
    if "last_target" in cols:      data["last_target"] = target
    if "last_status" in cols:      data["last_status"] = status
    if "status" in cols and "last_status" not in cols:  # legacy schema
        data["status"] = status

    # Optional columns
    if "ext" in cols:              data["ext"] = pathlib.Path(path).suffix.lower()
    if "last_size_bytes" in cols and st is not None: data["last_size_bytes"] = getattr(st, "st_size", None)
    if "last_mtime_ns"   in cols and st is not None: data["last_mtime_ns"]   = getattr(st, "st_mtime_ns", None)
    now = int(time.time())
    if "first_seen_ts" in cols:    data.setdefault("first_seen_ts", now)
    if "last_seen_ts"  in cols:    data["last_seen_ts"] = now
    if "is_current"    in cols:    data["is_current"] = 1

    # INSERT ... ON CONFLICT(path) DO UPDATE SET ...
    keys = list(data.keys())
    placeholders = ",".join("?" for _ in keys)
    assignments = []
    for k in keys:
        if k == "path": 
            continue
        # times_seen special handling
        if k == "times_seen":
            continue
        assignments.append(f"{k}=excluded.{k}")
    if "times_seen" in cols:
        assignments.append("times_seen=COALESCE(times_seen,0)+1")

    sql = f"INSERT INTO symlinks({','.join(keys)}) VALUES({placeholders}) " \
          f"ON CONFLICT(path) DO UPDATE SET {', '.join(assignments)}"
    conn.execute(sql, tuple(data[k] for k in keys))
    conn.commit()

def unlink_if_symlink(path: str):
    try:
        if os.path.islink(path):
            os.unlink(path)
            return True
    except Exception as e:
        log("WARNING", f"unlink failed {path}: {e}")
    return False

def update_symlink_status(conn, path: str, status: str):
    cols = table_cols(conn, "symlinks")
    now = int(time.time())
    if "last_status" in cols and "last_seen_ts" in cols:
        conn.execute("UPDATE symlinks SET last_status=?, last_seen_ts=?, is_current=1 WHERE path=?",
                     (status, now, path))
    elif "status" in cols:
        conn.execute("UPDATE symlinks SET status=? WHERE path=?", (status, path))
    else:
        # fallback: make sure row exists
        conn.execute("INSERT INTO symlinks(path,last_status) VALUES(?,?) ON CONFLICT(path) DO UPDATE SET last_status=excluded.last_status",
                     (path, status))
    conn.commit()

def scan_once():
    conn = db()
    ensure_actions(conn)
    root = pathlib.Path(SYMLINK_ROOT)
    if not root.exists():
        log("WARNING", f"SYMLINK_ROOT missing: {SYMLINK_ROOT}")
        return
    n_ok = n_broken = 0

    for p in root.rglob("*"):
        # âœ… skip ignored areas before any work
        if is_ignored_path(p):
            log("DEBUG", f"Skipping ignored path: {p}")
            continue

        if not p.is_symlink():
            continue
        try:
            broken, target = is_broken_symlink(p)
            st = p.lstat()
        except Exception:
            broken, target, st = True, None, None

        status = "broken" if broken else "ok"
        record_symlink(conn, str(p), target, status, st)
        if broken: n_broken += 1
        else: n_ok += 1

    log("INFO", f"Scan summary: {n_ok+n_broken} symlinks; {n_ok} ok; {n_broken} broken")


def get_pending(conn, limit=5):
    return conn.execute(
        "SELECT * FROM actions WHERE status='pending' ORDER BY created_utc LIMIT ?",
        (limit,)
    ).fetchall()

def mark_sent(conn, action_id: int, ok: bool, err: str=None):
    conn.execute("UPDATE actions SET status=?, last_error=? WHERE id=?",
                 ("sent" if ok else "failed", None if ok else (err or ""), action_id))
    conn.commit()

def process_actions():
    conn = db()
    ensure_actions(conn)
    rows = get_pending(conn, limit=5)
    if not rows:
        return
    log("INFO", f"processing {len(rows)} pending action(s)")
    for r in rows:
        aid = r["id"]
        url = r["url"]
        related = r["related_path"]
        try:
            if related:
                update_symlink_status(conn, related, "repairing")
                unlink_if_symlink(related)
            resp = requests.get(url, timeout=20)
            ok = 200 <= resp.status_code < 300
            if not ok:
                mark_sent(conn, aid, False, f"{resp.status_code} {resp.text}")
            else:
                mark_sent(conn, aid, True, None)
            log("INFO", f"ACTION {aid} -> {'OK' if ok else 'FAIL'}")
        except Exception as e:
            mark_sent(conn, aid, False, str(e))
            log("ERROR", f"ACTION {aid} exception: {e}")

def run_loop(interval_seconds: int = 300):
    log("INFO", f"loop every {interval_seconds}s")
    while True:
        try:
            scan_once()
        except Exception as e:
            log("ERROR", f"scan error: {e}")
        try:
            process_actions()
        except Exception as e:
            log("ERROR", f"actions error: {e}")
        time.sleep(interval_seconds)

if __name__ == "__main__":
    import argparse
    ap = argparse.ArgumentParser()
    ap.add_argument("--json", action="store_true")
    args = ap.parse_args()
    if args.json:
        try:
            scan_once()
            print(json.dumps({"ok": True}))
        except Exception as e:
            print(json.dumps({"ok": False, "error": str(e)}))
    else:
        run_loop(300)
